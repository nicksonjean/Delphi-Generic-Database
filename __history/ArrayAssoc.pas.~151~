{
  ArrayAssoc.
  ------------------------------------------------------------------------------
  Objetivo : Simplificar a criação de matrizes php-like em Delphi.
  Suporta 2 Tipos de Matrizes Associativas Unidimensionais:
  1 - Matriz de Strings Herdada de TStringList;
  2 - Matriz de Variants Herdada de TDictionary<String, Variant>
  ------------------------------------------------------------------------------
  Autor : Nickson Jeanmerson
  Colaborador : Ramon Ruan
  ------------------------------------------------------------------------------
  Esta biblioteca é software livre; você pode redistribuí-la e/ou modificá-la
  sob os termos da Licença Pública Geral Menor do GNU conforme publicada pela
  Free Software Foundation; tanto a versão 3.29 da Licença, ou (a seu critério)
  qualquer versão posterior.
  Esta biblioteca é distribuída na expectativa de que seja útil, porém, SEM
  NENHUMA GARANTIA; nem mesmo a garantia implícita de COMERCIABILIDADE OU
  ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA. Consulte a Licença Pública Geral Menor
  do GNU para mais detalhes. (Arquivo LICENÇA.TXT ou LICENSE.TXT)
  Você deve ter recebido uma cópia da Licença Pública Geral Menor do GNU junto
  com esta biblioteca; se não, escreva para a Free Software Foundation, Inc.,
  no endereço 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.
  Você também pode obter uma copia da licença em:
  http://www.opensource.org/licenses/lgpl-license.php
}

unit ArrayAssoc;

{$WARNINGS OFF}
{$HINTS OFF}

interface

uses
  System.Classes,
  System.SysUtils,
  System.Generics.Collections,
  System.RTLConsts,
  System.Variants,
  Data.DB,
  {Record para Conversão de Tipos}
  Conversion;

{ TODO 3 -oNickson Jeanmerson -cProgrammer :
1) Padronizar a Classes TArray e TArrayVariant; //OK
2) Padronizar a Classe TArrayField;
3) Criar Métodos Ausentes; }

{$REGION 'TArray'}
type
  TArray = class(TStringList)
  private
    { Private declarations }
    function GetKey(Index: Integer): String;
    function GetValues(Index: string): string;
    function GetValuesAtIndex(Index: Integer): string;
    procedure SetValues(Index: string; const Value: string);
  public
    { Public declarations }
    constructor Create;
    destructor Destroy; override;
    function ToFilter: string;
    function ToString: string;
    procedure AddKeyValue(Key, Value: string);
    procedure Add(Key, Value: string); overload;
    property Key[Index : Integer] : String read GetKey;
    property ValuesAtIndex[Index: Integer]: string read GetValuesAtIndex;
    property Values[Index: string]: string read GetValues write SetValues; default;
  end;
{$ENDREGION}

{$REGION 'TArrayVariant'}
type
  TArrayVariant = class(TDictionary<String, Variant>)
  private
    { Private declarations }
    function GetKey(Index: Integer): String;
    function GetValues(Name: string): Variant;
    function GetValuesAtIndex(Index: Integer): Variant;
    procedure SetValues(Name: String; const Value: Variant);

    function GetItem(Index: String): Variant;
    procedure SetItem(Index: String; const Value: Variant);
  public
    { Public declarations }
    destructor Destroy; override;
    function ToFilter: string;
    function ToString: string;
    procedure AddKeyValue(Key : String; Value : Variant);
    procedure Add(Key : String; Value : Variant);
    property Key[Index : Integer] : String read GetKey;
    property ValuesAtIndex[Index: Integer]: Variant read GetValuesAtIndex;
    property Values[Name: string]: Variant read GetValues write SetValues;

    property Item[Index: String]: Variant read GetItem write SetItem; default;
  end;
{$ENDREGION}

{$REGION 'TArrayField'}
type
  TArrayField = class(TDictionary<String, TField>)
  private
    { Private declarations }
    function GetKey(Index: Integer): String;
    function GetValues(Name: string): TField;
    function GetValuesAtIndex(Index: Integer): TField;
    procedure SetValues(Name: String; const Value: TField);
  public
    { Public declarations }
    destructor Destroy; override;
    procedure AddKeyValue(Key : String; Value : TField);
    property Key[Index : Integer] : String read GetKey;
    property ValuesAtIndex[Index: Integer]: TField read GetValuesAtIndex;
    property Values[Name: string]: TField read GetValues write SetValues;
  end;
{$ENDREGION}

implementation

{$REGION 'TArray'}
constructor TArray.Create;
begin
  NameValueSeparator := '|';
end;

destructor TArray.Destroy;
begin
  inherited;
end;

function TArray.ToFilter: string;
var
  I: Integer;
begin
  Result := '';
  for I := 0 to Count - 1 do
  begin
    Result := Result + Names[I] + ' ' + QuotedStr(ValuesAtIndex[I]) + ' ';
  end;
end;

function TArray.ToString: string;
var
  I: Integer;
begin
  Result := '';
  for I := 0 to Count - 1 do
  begin
    Result := Result + QuotedStr(ValuesAtIndex[I]);
  end;
end;

procedure TArray.Add(Key, Value: string);
begin
  Add(Key + NameValueSeparator + Value);
end;

procedure TArray.AddKeyValue(Key, Value: string);
begin
  Add(Key + NameValueSeparator + Value);
end;

function TArray.GetKey(Index: Integer): String;
begin
  inherited;
end;

function TArray.GetValues(Index: string): string;
begin
  Result := inherited Values[Index];
end;

function TArray.GetValuesAtIndex(Index: Integer): string;
begin
  Result := inherited Values[Names[Index]];
end;

procedure TArray.SetValues(Index: string; const Value: string);
begin
  inherited Values[Index] := Value;
end;
{$ENDREGION}

{$REGION 'TArrayVariant'}
destructor TArrayVariant.Destroy;
begin
  inherited;
end;

function TArrayVariant.ToFilter: string;
var
  I: Integer;
begin
  Result := '';
  for I := 0 to Count - 1 do
  begin
    Result := Result + Key[I] + ' ' + Convert.VarToStr(ValuesAtIndex[I]) + ' ';
  end;
end;

function TArrayVariant.ToString: string;
var
  I: Integer;
begin
  Result := '';
  for I := 0 to Count - 1 do
  begin
    Result := Result + Convert.VarToStr(ValuesAtIndex[I]);
  end;
end;

procedure TArrayVariant.Add(Key : String; Value : Variant);
begin
  inherited Add(Key, Value);
end;

procedure TArrayVariant.AddKeyValue(Key : String; Value : Variant);
begin
  inherited AddOrSetValue(Key, Value);
end;

function TArrayVariant.GetKey(Index: Integer): String;
begin
  Result := ToArray[Index].Key;
end;

function TArrayVariant.GetValues(Name: string): Variant;
var
  OutValue : Variant;
begin
  TryGetValue(Name, OutValue);
  Result := OutValue;
end;

procedure TArrayVariant.SetValues(Name: String; const Value: Variant);
begin
  Values[Name] := Value;
  //Forma Legada
  //AddOrSetValue(Name, Variant(Value));
end;

function TArrayVariant.GetItem(Index: String): Variant;
begin
  Result := ToArray[StrToInt(Index)].Key;
end;

procedure TArrayVariant.SetItem(Index: String; const Value: Variant);
begin
  inherited;
end;

function TArrayVariant.GetValuesAtIndex(Index: Integer): Variant;
var
  OutValue : Variant;
begin
  TryGetValue(Self.ToArray[Index].Key, OutValue);
  Result := OutValue;
end;
{$ENDREGION}

{$REGION 'TArrayField'}
destructor TArrayField.Destroy;
begin
  inherited;
end;

procedure TArrayField.AddKeyValue(Key: String; Value: TField);
begin
  AddKeyValue(Key, Value);
end;

function TArrayField.GetKey(Index: Integer): String;
begin
  Result := ToArray[Index].Key;
end;

function TArrayField.GetValues(Name: string): TField;
begin
  Result := Values[Name];
end;

function TArrayField.GetValuesAtIndex(Index: Integer): TField;
var
  OutValue : TField;
begin
  TryGetValue(Self.ToArray[Index].Key, OutValue);
  Result := OutValue;
end;

procedure TArrayField.SetValues(Name: String; const Value: TField);
begin
  Values[Name] := Value;
end;
{$ENDREGION}

{$WARNINGS ON}
{$HINTS ON}

end.
