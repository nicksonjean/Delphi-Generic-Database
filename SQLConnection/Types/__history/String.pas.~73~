{
  &String.
  ------------------------------------------------------------------------------
  Objetivo : Simplificar a criação de matrizes php-like em Delphi.
  Suporta 1 Tipo de Matriz Associativa Unidimensional Baseada em TStringList;
  Suporta 2 Tipos de Matrizes Associativas Unidimensionais Baseadas em TDicionary;
  Suporte 2 Tipos de Matrizes Associativas Multidimensional Baseadas em TDicionary;
  1 - Matriz de Strings Herdada de TStringList;
  2 - Matriz de Variants Herdada de TDictionary<Variant, Variant>
  3 - Matriz de Fields Herdade de TDictionay<Variant, TField>
  4 - Matriz de Matrizes Herdada de TDicionary<TDictionay<Variant, Variant>>
  5 - Matriz de Matrizes Herdada de TDicionary<TDictionay<Variant, TField>>
  ------------------------------------------------------------------------------
  Autor : Nickson Jeanmerson
  ------------------------------------------------------------------------------
  Esta biblioteca é software livre; você pode redistribuí-la e/ou modificá-la
  sob os termos da Licença Pública Geral Menor do GNU conforme publicada pela
  Free Software Foundation; tanto a versão 3.29 da Licença, ou (a seu critério)
  qualquer versão posterior.
  Esta biblioteca é distribuída na expectativa de que seja útil, porém, SEM
  NENHUMA GARANTIA; nem mesmo a garantia implícita de COMERCIABILIDADE OU
  ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA. Consulte a Licença Pública Geral Menor
  do GNU para mais detalhes. (Arquivo LICENÇA.TXT ou LICENSE.TXT)
  Você deve ter recebido uma cópia da Licença Pública Geral Menor do GNU junto
  com esta biblioteca; se não, escreva para a Free Software Foundation, Inc.,
  no endereço 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.
  Você também pode obter uma copia da licença em:
  http://www.opensource.org/licenses/lgpl-license.php

https://stackoverflow.com/questions/14274089/incompatible-char-and-widechar-in-delphi
https://github.com/eversonturossi/delphi-exemplo-sistema/blob/master/Fonte%20PAF-ECF-TEF_/Aplicativo_Gerencial/Biblioteca/UBarsa.~pas
https://stackoverflow.com/questions/4070094/create-a-constant-array-of-strings
https://stackoverflow.com/questions/1872503/how-to-assign-a-multiline-string-value-without-quoting-each-line
https://stackoverflow.com/questions/246969/is-it-possible-do-declare-a-constant-array-that-includes-another-constant-array
https://stackoverflow.com/questions/17460378/possible-to-concatenate-constant-array-of-string
https://stackoverflow.com/questions/30156172/how-to-concatenate-array-of-string-elements-into-a-string
https://stackoverflow.com/questions/17460378/possible-to-concatenate-constant-array-of-string?noredirect=1&lq=1
}

unit &String;

interface

uses
  System.SysUtils,
  System.StrUtils,
  System.Generics.Collections,
  System.RegularExpressions,
  System.RTLConsts,
  System.Variants,
  System.Rtti,
  Data.DB,
  REST.JSON;

const
  EMPTYCHAR : Char = #0; //EmptyStr para Char
  TAB : Char = #10; //<TAB>
  ENTER : Char = #13; //<ENTER>
  SQUOTE : Char = #39; //'
  DQUOTE : Char = #34; //"
  COMMA : Char = #44; //,
  COLON : Char = #58; //:
  LTAG : Char = #60; //<
  EQUAL : Char = #61; //=
  RTAG : Char = #62; //>
  LBRACKET : Char = #123; //{
  PIPE : Char = #124; //|
  RBRACKET : Char = #125; //}
  CBAR : Char = #92; //\
  SSPACE : Char = #32; //\s
  CTAG : String = '</';
  DSPACE : String = '  '; //\s\s
  EOL : String = #10#13; //\r\n
  XML : String = '<?xml version="1.0" encoding="UTF-8"?>';
  NULSTR : String = 'null';
  NUL : String = '\b(\w*null|NULL\w*)\b';
  SYMBOLS = '[-()\"#\/@;:<>{}`+=~|?!@#$%^&*a-zA-Z\s]';
  NUMERIC : String = '^\-?\d{1,}$';
  DECIMAL : String = '^\d*[\,]?\d*$';

type
  TString = class
  private
    { Private declarations }
  public
    { Public declarations }
    class function OnlyAlpha(Text: String): String; static;
    class function OnlyValues(Text: String): String; static;
    class function OnlyNumeric(Text: String): String; static;
    class function OnlyAlphaNumeric(Text: String): String; static;
    class function IsNull(Text: String): Boolean;
    class function IsNumeric(Text: String): Boolean;
    class function IsDecimal(Text: String): Boolean;
    class function IsDateOrDateTime(Text: String): Boolean;
    class function EscapeStrings(Text: String): String;
    class function FromTags(Input, Column: String): String;
    class function IndentTag(Input, Replace : String): String;
    class function RemoveLastComma(Input : String): String;
    class function RemoveLastCommaEOL(Input : String): String;
    class function RemoveLastEOL(Input : String): String;
    class function RemoveSpecialChars(Text : String): String;
    class function ExtractStringBetweenDelimiters(Input: String; Delim1, Delim2: String): String;
    class function StringReplace(Text: String; OldPattern, NewPattern: TArray<String>; Flags: TReplaceFlags): String;
    class function StrArrayJoin(const StringArray: array of string; const Separator: string) : string;
    class function JoinStrings(const s: array of string; Delimiter: Char): string;
    class function Quote(Text : String; Quote: String = #39): String;
  end;

implementation

{ TString }

class function TString.OnlyAlpha(Text: String): String;
begin
  Result := Trim(TRegEx.Replace(Text, '[^\w]', ''));
end;

class function TString.OnlyValues(Text: String): String;
begin
  Result := Trim(TRegEx.Replace(Text, Symbols, ''));
end;

class function TString.Quote(Text : String; Quote: String = #39): String;
begin
  Result := Quote + Text + Quote;
end;

class function TString.OnlyNumeric(Text: String): String;
begin
  Result := Trim(TRegEx.Replace(Text, '[^\d]', ''));
end;

class function TString.OnlyAlphaNumeric(Text: String): String;
begin
  Result := Trim(TRegEx.Replace(Text, '[^\d\w]', ''));
end;

class function TString.IsNull(Text: String): Boolean;
begin
  Result := TRegEx.IsMatch(Text, NUL);
end;

class function TString.IsNumeric(Text: String): Boolean;
begin
  Result := TRegEx.IsMatch(Text, NUMERIC);
end;

class function TString.IsDecimal(Text: String): Boolean;
begin
  Result := TRegEx.IsMatch(Text, DECIMAL);
end;

class function TString.IsDateOrDateTime(Text: String): Boolean;
var
  RegEx: String;
begin
  (*
    //https://stackoverflow.com/questions/13194322/php-regex-to-check-date-is-in-yyyy-mm-dd-format
    yyyy-mm-dd : /^((((19|[2-9]\d)\d{2})\-(0[13578]|1[02])\-(0[1-9]|[12]\d|3[01]))|(((19|[2-9]\d)\d{2})\-(0[13456789]|1[012])\-(0[1-9]|[12]\d|30))|(((19|[2-9]\d)\d{2})\-02\-(0[1-9]|1\d|2[0-8]))|(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))\-02\-29))$/g
    yyyy/mm/dd : /^((((19|[2-9]\d)\d{2})\/(0[13578]|1[02])\/(0[1-9]|[12]\d|3[01]))|(((19|[2-9]\d)\d{2})\/(0[13456789]|1[012])\/(0[1-9]|[12]\d|30))|(((19|[2-9]\d)\d{2})\/02\/(0[1-9]|1\d|2[0-8]))|(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))\/02\/29))$/g
    mm-dd-yyyy : /^(((0[13578]|1[02])\-(0[1-9]|[12]\d|3[01])\-((19|[2-9]\d)\d{2}))|((0[13456789]|1[012])\-(0[1-9]|[12]\d|30)\-((19|[2-9]\d)\d{2}))|(02\-(0[1-9]|1\d|2[0-8])\-((19|[2-9]\d)\d{2}))|(02\-29\-((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$/g
    mm/dd/yyyy : /^(((0[13578]|1[02])\/(0[1-9]|[12]\d|3[01])\/((19|[2-9]\d)\d{2}))|((0[13456789]|1[012])\/(0[1-9]|[12]\d|30)\/((19|[2-9]\d)\d{2}))|(02\/(0[1-9]|1\d|2[0-8])\/((19|[2-9]\d)\d{2}))|(02\/29\/((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$/g
    dd/mm/yyyy : /^(((0[1-9]|[12]\d|3[01])\/(0[13578]|1[02])\/((19|[2-9]\d)\d{2}))|((0[1-9]|[12]\d|30)\/(0[13456789]|1[012])\/((19|[2-9]\d)\d{2}))|((0[1-9]|1\d|2[0-8])\/02\/((19|[2-9]\d)\d{2}))|(29\/02\/((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$/g
    dd-mm-yyyy : /^(((0[1-9]|[12]\d|3[01])\-(0[13578]|1[02])\-((19|[2-9]\d)\d{2}))|((0[1-9]|[12]\d|30)\-(0[13456789]|1[012])\-((19|[2-9]\d)\d{2}))|((0[1-9]|1\d|2[0-8])\-02\-((19|[2-9]\d)\d{2}))|(29\-02\-((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$/g
    //http://docwiki.embarcadero.com/Libraries/Tokyo/en/System.SysUtils.DateTimeToString
  *)
  RegEx := EmptyStr;
  RegEx := RegEx + '^(([0-2]\d|[3][0-1])\/([0]\d|[1][0-2])\/[2][0]\d{2})$|^(([0-2]\d|[3][0-1])\/([0]\d|[1][0-2])\/[2][0]\d{2}\s([0-1]\d|[2][0-3])\:[0-5]\d\:[0-5]\d)$';
  Result := TRegEx.IsMatch(Text, RegEx);
end;

{ TStringHelper }

class function TString.EscapeStrings(Text: string): string;
begin
  Result := Self.StringReplace(Text, [CBar, DQuote, NULL, TAB, ENTER], [CBAR+CBAR, CBAR+DQUOTE, EmptyStr, '\r', '\n'], [rfReplaceAll]);
end;

class function TString.StringReplace(Text: string; OldPattern, NewPattern: TArray<String>; Flags: TReplaceFlags): string;
var
  I: Integer;
begin
  Assert(Length(OldPattern) = (Length(NewPattern)));
  Result := Text;
  for I := Low(OldPattern) to High(OldPattern) do
    Result := System.SysUtils.StringReplace(Result, OldPattern[I], NewPattern[I], Flags);
end;

class function TString.ExtractStringBetweenDelimiters(Input: String; Delim1, Delim2: String): String;
var
  aPos, bPos: Integer;
begin
  result := '';
  aPos := Pos(Delim1, Input);
  if aPos > 0 then begin
    bPos := PosEx(Delim2, Input, aPos + Length(Delim1));
    if bPos > 0 then begin
      result := Copy(Input, aPos + Length(Delim1), bPos - (aPos + Length(Delim1)));
    end;
  end;
end;

class function TString.IndentTag(Input, Replace: String): String;
var
  Regex: TRegEx;
begin
  Regex := TRegEx.Create('^(<)', [roMultiLine]);
  Result := Regex.Replace(Input, Replace);
end;

class function TString.FromTags(Input, Column: String): String;
begin
  Result := Self.ExtractStringBetweenDelimiters(Input, LTAG + Column + RTAG, CTAG + Column + LTAG);
end;

class function TString.RemoveLastComma(Input: String): String;
begin
  if Input[Length(Input)-2] = Comma then
    System.Delete(Input, Length(Input)-2, 1)
  else
    System.Delete(Input, Length(Input), 1);
  Result := Input;
end;

class function TString.RemoveLastCommaEOL(Input: String): String;
begin
  if Input[Length(Input)-2] = Comma then
    System.Delete(Input, Length(Input)-2, 3)
  else
    System.Delete(Input, Length(Input)-1, 2);
  Result := Input;
end;

class function TString.RemoveLastEOL(Input: String): String;
begin
  if Input[Length(Input)-1] = EOL then
    System.Delete(Input, Length(Input)-1, 2);
  Result := Input;
end;

class function TString.RemoveSpecialChars(Text : String): String;
begin
  Result := Self.StringReplace(Text, [TAB, ENTER, EOL], [EmptyStr, EmptyStr, EmptyStr], [rfReplaceAll]);
end;

class function TString.StrArrayJoin(const StringArray: array of string; const Separator: string) : string;
var
  i : Integer;
begin
  Result := '';
  for i := low(StringArray) to high(StringArray) do
    Result := Result + StringArray[i] + Separator;
  Delete(Result, Length(Result), 1);
end;

class function TString.JoinStrings(const s: array of string; Delimiter: Char): string;
var
  i, c: Integer;
  p: PChar;
begin
  c := 0;
  for i := 0 to High(s) do
    Inc(c, Length(s[i]));
  SetLength(Result, c + High(s));
  p := PChar(Result);
  for i := 0 to High(s) do begin
    if i > 0 then begin
      p^ := Delimiter;
      Inc(p);
    end;
    Move(PChar(s[i])^, p^, SizeOf(Char)*Length(s[i]));
    Inc(p, Length(s[i]));
  end;
end;

end.
